#!/usr/bin/env python

'''
ECE3091 Group 5

This node is a publisher outputs motor cmds by taking in obstacles
and targets generated by computer vision ndoe

Publishes to:
    /actuators/motor_cmds

Subscribes to:
    /planner/obstacles
    /planner/targets

Written by Josh Cherubino
Last edited 29/09/21 by Josh Cherubino
'''

import rospy
import math
from ece3091.msg import MotorCmd, Obstacles, Targets, OdometryData

RATE = 50
SEARCH_SPEED = 0.2

class PathPlanner(object):
    '''
    Class to plan a path given a feature map and current x y coordintes and orientation.

    Implements a state machine to control what type of movement the robot does
    at a particular instant
    '''
    def __init__(self):
        self.targets = None
        self.obstacles = None

        #states for state machine
        self.SEARCH = 0 #no targets. search arena for possible targets
        self.ALIGN = 1 #target found but not in front of robot
        self.APPROACH = 2 #target found and aligned
        self.CIRCUMVENT = 3 #obstacle too close to robot
        self.COLLECT = 4 #target in correct position. Must pick up
        self.state = self.SEARCH #initially searching for target

        #table to map current state to function to execute
        self.STEP_TABLE = [self.search, self.align, self.approach, self.circumvent,
                self.collect]

        #motor cmds
        self.STOP = 0
        self.FORWARD = 1
        self.REVERSE = 2
        self.CW = 3
        self.CCW = 4

    def search(self):
        '''
        Search state.
        '''
        #if we have an obstacle
        if self.collision_imminent():
            self.state = self.CIRCUMVENT
            return MotorCmd(self.STOP, 0.0)

        #if we have a target
        if targets is not None and targets.x:
            #move to align state
            rospy.loginfo('Target found. Aligning')
            self.state = self.ALIGN
            return MotorCmd(self.STOP, 0.0)
        
        #if no target, then keep rotating
        return MotorCmd(self.CW, SEARCH_SPEED) 

    def align(self):
        #if we have an obstacle
        if self.collision_imminent():
            rospy.logwarn('Collision imminent. Circumventing')
            self.state = self.CIRCUMVENT
            return MotorCmd(self.STOP, 0.0)

        #check align
        if self.aligned():
            rospy.loginfo('Aligned. Approaching')
            self.state = self.APPROACH
            return MotorCmd(self.STOP, 0.0)
        
        #TODO: otherwise, rotate to alignment
        return MotorCmd(self.STOP, 0.0)

    def approach(self):
        #if we have an obstacle
        if self.collision_imminent():
            rospy.logwarn('Collision imminent. Circumventing')
            self.state = self.CIRCUMVENT
            return MotorCmd(self.STOP, 0.0)
        
        #check arrived
        if self.arrived():
            rospy.loginfo('Arrived. Collecting')
            self.state = self.COLLECT
            return MotorCmd(self.STOP, 0.0)
        
        #check alignment has shifted
        if !self.aligned():
            rospy.logwarn('Alignment lost. Re-aligning')
            self.state = self.ALIGN
            return MotorCmd(self.STOP, 0.0)

        #TODO: otherwise drive in straight line
        return MotorCmd(self.STOP, 0.0)

    def circumvent(self):
        if !self.collision_imminent():
            rospy.loginfo('Object avoided. Searching')
            self.state = self.SEARCH
            return MotorCmd(self.STOP, 0.0)
        
        #TODO: Avoid...
        return MotorCmd(self.STOP, 0.0)        

    def collect(self):
        #Call collect service
        #Move to search state
        #TODO: Handle blocking service call.
        self.state = self.SEARCH
        return MotorCmd(self.STOP, 0.0)        

    def collision_imminent(self):
        pass

    def aligned(self):
        pass

    def obstacle_callback(self, obstacles):
        '''
        Update obstacles
        NB obstacles store list of x, y coordinates
        of bottom left and right corner of detected obstacles
        '''
        self.obstacles = obstacles

    def target_callback(self, targets):
        '''
        Update targets
        NB targets are list of x, y coordinates representing centre of detected
        targets
        '''
        self.targets = targets

    def proportional_control(self, target, current):
        '''
        Proportional speed control function
        that clips output in 0 to 1 range
        '''
        try:
            error = abs(target - current)/target
        except ZeroDivisionError:
            return 0.0
        #apply Kp or clip values if necessary
        return max(0.0, min(Kp*error, 1.0))
    
    def step(self):
        '''
        Given current state and available data, execute one 'step' in appropriate
        direction
        '''
        #defer to state callbacks to handle determining next step
        return self.STEP_TABLE[self.state]()

def path_planner_node():
    pub = rospy.Publisher('/actuators/motor_cmds', MotorCmd, queue_size=2)
    rospy.init_node('path_planner_node', anonymous=False)

    planner = PathPlanner() 

    obstacle_sub = rospy.Subscriber('/planner/obstacles', Obstacles, planner.obstacle_callback)
    target_sub = rospy.Subscriber('/planner/targets', Targets, planner.target_callback)

    rate = rospy.Rate(RATE)
    rospy.loginfo('Starting path planner node')
    
    while not rospy.is_shutdown():
        msg = planner.step() #take step in most appropriate direction
        pub.publish(msg)
        rate.sleep()

if __name__ == '__main__':
    try:
        path_planner_node()
    except rospy.ROSInterruptException:
        pass

