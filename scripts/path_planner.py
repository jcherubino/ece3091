#!/usr/bin/env python

'''
ECE3091 Group 5

This node is a publisher outputs motor cmds by taking in obstacles
and targets generated by computer vision ndoe

Publishes to:
    /actuators/motor_cmds

Subscribes to:
    /planner/obstacles
    /planner/targets

Written by Josh Cherubino
Last edited 29/09/21 by Josh Cherubino
'''

import rospy
import math
import random
import time
from ece3091.msg import MotorCmd, Obstacles, Targets

RATE = rospy.get_param('/picam/framerate')
SEARCH_SPEED = 0.6
ALIGN_SPEED = 0.3
APPROACH_SPEED = 0.5
COLLECT_SPEED = 0.7
CIRCUMVENT_SPEED = 0.6

SEARCH_PEEK_INTERVAL = 10050 #every X ticks peerk to right
SEARCH_PEEK_TIME = 150 #how long to turn for during peek
ALIGN_TOL = 2 #+/- cm alignment tolerance for targets
ARRIVE_TOL = 16
MIN_OBSTACLE_DISTANCE = 19 #object can't be closer than this 
COLLECT_LOOPS = 170 #how many times to 'step' before leaving collect state
SEARCH_WAIT_LOOPS = 10 #how many loops to wait after entering search in case we just lost reading for a short amount of time
COLLISION_OVERTURN = 25 #how many loops after we can't see object to keep turning

class PathPlanner(object):
    '''
    Class to plan a path given obstacles and targets in relative xy coordinates to front of robot

    Implements a state machine to control what type of movement the robot does
    at a particular instant
    '''
    def __init__(self):
        self.targets = None
        self.obstacles = None
        self.collect_idx = None
        self.search_idx = None
        self.circumvent_direction = None
        self.circumvent_overturn = None

        #states for state machine
        self.SEARCH = 0 #no targets. search arena for possible targets
        self.ALIGN = 1 #target found but not in front of robot
        self.APPROACH = 2 #target found and aligned
        self.CIRCUMVENT = 3 #obstacle too close to robot
        self.COLLECT = 4 #target in correct position. Must pick up
        self.state = self.SEARCH #initially searching for target

        #table to map current state to function to execute
        self.STEP_TABLE = [self.search, self.align, self.approach, self.circumvent,
                self.collect]

        #motor cmds
        self.STOP = 0
        self.FORWARD = 1
        self.REVERSE = 2
        self.CW = 3
        self.CCW = 4

        self.search_dir = self.CCW

    def search(self):
        '''
        Search state.
        '''
        if self.collision_imminent():
            rospy.logwarn('Collision imminent. Circumventing')
            self.state = self.CIRCUMVENT
            self.search_idx = None
            return MotorCmd(self.STOP, 0.0)

        if self.search_idx is None:
            self.search_idx = 0
            self.peeking = False

        #if we have a target
        if self.targets is not None and self.targets.x:
            #move to align state
            rospy.loginfo('Target(s) found ({}, {}). Aligning'.format(self.targets.x, 
                self.targets.y))
            self.state = self.ALIGN
            self.search_idx = None
            return MotorCmd(self.STOP, 0.0)
        
        #check if we have to keep waiting
        self.search_idx += 1

        if self.search_idx <= SEARCH_WAIT_LOOPS:
            return MotorCmd(self.STOP, 0.0)
    
        #commence peek
        if self.peeking == False and self.search_idx % SEARCH_PEEK_INTERVAL == 0:
            rospy.loginfo('Starting peek')
            self.peeking = True
            self.end_of_peek = self.search_idx + SEARCH_PEEK_TIME
            rospy.logdebug('Current idx: {} End of peek: {}'.format(self.search_idx,
                self.end_of_peek))
        
        if self.peeking == True:
            #turning 'out'
            if self.search_idx < self.end_of_peek:
                return MotorCmd(self.CW, 0.5) 
            #turning in
            elif self.search_idx < self.end_of_peek+SEARCH_PEEK_TIME:
                rospy.logdebug('Turning in')
                return MotorCmd(self.CCW, 0.5)
            #peek done
            else:
                rospy.loginfo('Peek done')
                self.peeking = False
    
        #driving straight
        return MotorCmd(self.FORWARD, SEARCH_SPEED)

    def align(self):
        #N.B. Assume collision can't occur when we rotate on spot so never check
        if self.targets is None or not self.targets.x:
            #target lost
            rospy.loginfo('Target(s) lost. Searching')
            self.state = self.SEARCH
            return MotorCmd(self.STOP, 0.0)
        #check align
        target = self.select_target()
        if self.aligned(target):
            rospy.loginfo('Aligned. Approaching {}'.format(target))
            self.state = self.APPROACH
            return MotorCmd(self.STOP, 0.0)
        
        #If we reach this point. Must continue aligning
        align_dist = target[0]
        if align_dist < 0:
            direction = self.CCW
        else:
            direction =  self.CW

        return MotorCmd(direction, ALIGN_SPEED)

    def aligned(self, target):
        '''
        Helper function to calculate alignment to target
        '''
        #scale alignment requirements depending on how far we are
        #as ratio to what we consider 'arrived'
        tolerance = target[1]/ARRIVE_TOL*ALIGN_TOL
        if abs(target[0]) < tolerance:
            #rospy.logdebug('Aligned, alignment: {} with tolerance {}'.format(abs(target[0]),
            #    tolerance))
            return True
        return False

    def select_target(self):
        '''
        Method to return the selected target the robot will navigate towards
        given its current targets
        '''
        min_distance = float('inf')
        closest_target = None
        #Choose closest target
        for x, y in zip(self.targets.x, self.targets.y):
            dist = self.distance(x, y)
            if dist < min_distance:
                min_distance = dist
                closest_target = (x, y)
        return closest_target

    def approach(self):
        #if we have an obstacle
        if self.collision_imminent():
            rospy.logwarn('Collision imminent. Circumventing')
            self.state = self.CIRCUMVENT
            return MotorCmd(self.STOP, 0.0)
        
        if self.targets is None or not self.targets.x:
            #target lost
            rospy.loginfo('Target(s) lost. Searching')
            self.state = self.SEARCH
            return MotorCmd(self.STOP, 0.0)

        #check arrived
        target = self.select_target()
        if self.arrived(target):
            rospy.loginfo('Arrived. Collecting')
            self.state = self.COLLECT
            return MotorCmd(self.STOP, 0.0)
        
        #check alignment has not shifted
        if not self.aligned(target):
            rospy.logwarn('Alignment lost. Re-aligning')
            self.state = self.ALIGN
            return MotorCmd(self.STOP, 0.0)

        #rospy.logdebug('Y Distance to target : {}'.format(target[1]))
        #Otherwise drive in straight line
        return MotorCmd(self.FORWARD, APPROACH_SPEED)

    def arrived(self, target):
        '''
        Helper function to decide if we have arrived at a target
        '''
        if target[1] <= ARRIVE_TOL:
            rospy.logdebug('Arrived. Target y dist: {}'.format(target[1]))
            return True
        return False

    def circumvent(self):
        if not self.collision_imminent():
            if self.circumvent_overturn is None:
                self.circumvent_overturn = 0
            if self.circumvent_overturn < COLLISION_OVERTURN:
                self.circumvent_overturn += 1
                return MotorCmd(self.circumvent_direction, CIRCUMVENT_SPEED)

            rospy.loginfo('Object avoided. Searching')
            self.state = self.SEARCH
            self.circumvent_overturn = None
            self.circumvent_direction = self.CW
            #invert search dir so next time we zig its in opposite direction
            #will avoid getting stuck in infinite loop with object hopefully
            #self.search_dir = self.CCW if self.search_dir == self.CW else self.CW
            return MotorCmd(self.STOP, 0.0)
        
        #choose direction
        if self.circumvent_direction is None:
            '''
            #just turn until we can't see the points anymore
            #choose turning direction based on closest obstacle
            min_dist = float('inf')
            direction = None
            for lx, ly, rx, ry in zip(self.obstacles.lx, self.obstacles.ly, 
                    self.obstacles.rx, self.obstacles.ry):
                ldist = self.distance(lx, ly)
                rdist = self.distance(rx, ry)
                rospy.logdebug('Left: {}. Right. {}'.format((lx, ly), (rx, ry)))
                rospy.logdebug('ldist: {}. rdist: {}'.format(ldist, rdist))
                if ldist < MIN_OBSTACLE_DISTANCE and rdist < MIN_OBSTACLE_DISTANCE:
                    if abs(lx) < abs(rx) and abs(lx) < min_dist:
                        rospy.logdebug('lx smaller than rx')
                        min_dist = abs(lx)
                        direction  = self.CCW
                    elif abs(rx) <= abs(lx) and abs(rx) < min_dist:
                        rospy.logdebug('rx smaller than lx')
                        min_dist = abs(rx)
                        direction = self.CW
                elif ldist < MIN_OBSTACLE_DISTANCE:
                    min_dist = abs(lx)
                    direction = self.CCW
                else:
                    min_dist = abs(rx)
                    direction = self.CW

            #default
            if direction is None:
                direction = self.CW
            rospy.logdebug('Turn dir: {}'.format('CCW' if direction == self.CCW else 'CW'))
            self.circumvent_direction = direction
            '''
            self.circumvent_direction = self.CW
        
        return MotorCmd(self.circumvent_direction, CIRCUMVENT_SPEED)

    def collect(self):
        #initialise
        if self.collect_idx is None:
            self.collect_idx = 0
        
        #check if done
        if self.collect_idx >= COLLECT_LOOPS:
            self.collect_idx = None
            self.state = self.SEARCH
            rospy.loginfo('Collection done. Moving to search')
            return MotorCmd(self.STOP, 0.0)
        
        self.collect_idx += 1
        return MotorCmd(self.FORWARD, COLLECT_SPEED)

    def collision_imminent(self):
        '''
        Detect of obstacle collision is imminent
        '''
        #object base is between (lx, ly) and (rx, ry)
        if self.obstacles is None:
            return False

        for lx, ly, rx, ry in zip(self.obstacles.lx, self.obstacles.ly, 
                self.obstacles.rx, self.obstacles.ry):
            #calculate distance of extremities. If any is too close, don't need to check any further
            #rospy.logdebug('Left dist: {}, Right dist: {}'.format(self.distance(lx, ly),
            #   self.distance(rx, ry)))
            if self.distance(lx, ly) <= MIN_OBSTACLE_DISTANCE or \
                    self.distance(rx, ry) <= MIN_OBSTACLE_DISTANCE or\
                    self.distance((lx+rx)/2, (ly+ry)/2) <= MIN_OBSTACLE_DISTANCE:
                return True
        return False
    
    @staticmethod
    def distance(x, y):
        '''
        Helper static method to calculate distance to x, y coordinate
        '''
        return math.sqrt(x**2 + y**2)

    def obstacle_callback(self, obstacles):
        '''
        Update obstacles
        NB obstacles store list of x, y coordinates
        of bottom left and right corner of detected obstacles
        '''
        self.obstacles = obstacles

    def target_callback(self, targets):
        '''
        Update targets
        NB targets are list of x, y coordinates representing centre of detected
        targets
        '''
        self.targets = targets

    def step(self):
        '''
        Given current state and available data, execute one 'step' in appropriate
        direction
        '''
        #defer to state callbacks to handle determining next step
        return self.STEP_TABLE[self.state]()

pub = rospy.Publisher('/actuators/motor_cmds', MotorCmd, queue_size=2)

def path_planner_node():
    rospy.init_node('path_planner_node', anonymous=False, log_level=rospy.INFO)

    planner = PathPlanner() 

    obstacle_sub = rospy.Subscriber('/planner/obstacles', Obstacles, planner.obstacle_callback)
    target_sub = rospy.Subscriber('/planner/targets', Targets, planner.target_callback)

    rate = rospy.Rate(RATE)
    rospy.loginfo('Starting path planner node')
    
    rospy.on_shutdown(shutdown)
    while not rospy.is_shutdown():
        msg = planner.step() #take step in most appropriate direction
        pub.publish(msg)
        rate.sleep()

def shutdown():
    pub.publish(MotorCmd(0, 0.0))

if __name__ == '__main__':
    try:
        path_planner_node()
    except rospy.ROSInterruptException:
        pass

