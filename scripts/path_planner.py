#!/usr/bin/env python

'''
ECE3091 Group 5

This node is a publisher outputs motor cmds by taking in obstacles
and targets generated by computer vision ndoe

Publishes to:
    /actuators/motor_cmds

Subscribes to:
    /planner/obstacles
    /planner/targets

Written by Josh Cherubino
Last edited 29/09/21 by Josh Cherubino
'''

import rospy
import math
import time
from ece3091.msg import MotorCmd, Obstacles, Targets
from std_srvs.srv import Trigger

RATE = 50
SEARCH_SPEED = 0.2
ALIGN_TOL = 5 #+/- degree alignment tolerance for targets
Kp = 0.8 #proportional constant for speed control
ARRIVE_TOL = (2, 5)
MIN_OBSTACLE_DISTANCE = 5 #object can't be closer than 5cm
CIRCUMVENT_X_DIST = 1.5
CIRCUMVENT_SPEED = 0.4
CIRCUMVENT_Y_DIST = 1.5
#TODO: Update robot width
ROBOT_X_WIDTH = 10

class PathPlanner(object):
    '''
    Class to plan a path given obstacles and targets in relative xy coordinates to front of robot

    Implements a state machine to control what type of movement the robot does
    at a particular instant
    '''
    def __init__(self):
        self.targets = None
        self.obstacles = None

        #states for state machine
        self.SEARCH = 0 #no targets. search arena for possible targets
        self.ALIGN = 1 #target found but not in front of robot
        self.APPROACH = 2 #target found and aligned
        self.CIRCUMVENT = 3 #obstacle too close to robot
        self.COLLECT = 4 #target in correct position. Must pick up
        self.state = self.SEARCH #initially searching for target

        #table to map current state to function to execute
        self.STEP_TABLE = [self.search, self.align, self.approach, self.circumvent,
                self.collect]

        #motor cmds
        self.STOP = 0
        self.FORWARD = 1
        self.REVERSE = 2
        self.CW = 3
        self.CCW = 4

    def search(self):
        '''
        Search state.
        '''
        #Assume collision can't occur when we rotate on spot so never check

        #if we have a target
        if self.targets is not None and self.targets.x:
            #move to align state
            rospy.loginfo('Target found. Aligning')
            self.state = self.ALIGN
            return MotorCmd(self.STOP, 0.0)
        
        #if no target, then keep rotating at constant speed
        return MotorCmd(self.CW, SEARCH_SPEED) 

    def align(self):
        #Assume collision can't occur when we rotate on spot so never check
        #check align
        target = self.select_target()
        if self.aligned(target):
            rospy.loginfo('Aligned. Approaching')
            self.state = self.APPROACH
            return MotorCmd(self.STOP, 0.0)
        
        #If we reach this point. Must continue aligning
        align_degrees = self.calculate_align(target)
        #if more than 90 degrees, rotate CCW
        if align_degrees > 90.0:
            direction = self.CCW
        else:
            direction = self.CW
        
        speed = self.proportional_control(align_degrees, 90.0)
        return MotorCmd(direction, speed)

    def calculate_align(self, target):
        '''
        Calculate degrees alignment to a given target as (x, y) tuple
        '''
        #TODO: Check if this output has appropriate sign
        return 90.0 - math.degrees(math.atan(target[1]/target[0]))

    def aligned(self, target):
        '''
        Helper function to calculate alignment to target
        '''
        #robot is aligned when target at 90 degrees (i.e. infront of it)
        if (abs(self.calculate_align(target)) - 90.0)  > ALIGN_TOL:
            return False
        return True

    def select_target(self):
        '''
        Method to return the selected target the robot will navigate towards
        given its current targets
        '''
        min_distance = float('inf')
        closest_target = None
        #Choose closest target
        for x, y in enumerate(self.target.x, self.target.y):
            dist = self.distance(x, y)
            if dist < min_distance:
                min_distance = dist
                closest_target = (x, y)
        return closest_target

    def approach(self):
        #if we have an obstacle
        if self.collision_imminent():
            rospy.logwarn('Collision imminent. Circumventing')
            self.state = self.CIRCUMVENT
            return MotorCmd(self.STOP, 0.0)
        
        #check arrived
        target = self.select_target()
        if self.arrived(target):
            rospy.loginfo('Arrived. Collecting')
            self.state = self.COLLECT
            return MotorCmd(self.STOP, 0.0)
        
        #check alignment has not shifted
        if not self.aligned(target):
            rospy.logwarn('Alignment lost. Re-aligning')
            self.state = self.ALIGN
            return MotorCmd(self.STOP, 0.0)

        #Otherwise drive in straight line
        #TODO: Test if just checking y distance for speed control is ok
        #TODO: Check target of 0 behaves as expected
        speed = self.proportional_control(target[1], 0.0)
        return MotorCmd(self.FORWARD, speed)

    def arrived(self, target):
        '''
        Helper function to decide if we have arrived at a target
        '''
        #TODO: Tune arrived parameters.
        if abs(target[0]) < ARRIVE_TOL[0] and abs(target[1]) < ARRIVE_TOL[1]:
            return True
        return False

    def circumvent(self):
        #Avoid obstacles. Should only be in this state when we are either
        #approaching a target or circumventing another obstacle already.
        if not self.collision_imminent():
            rospy.loginfo('Object avoided. Searching')
            self.state = self.SEARCH
            return MotorCmd(self.STOP, 0.0)
        
        critical_x, critical_y = [], []
        directions = []
        LEFT, RIGHT = 0, 1
        for lx, ly, rx, ry in enumerate(obstacles.lx, obstacles.ly, obstacles.rx, obstacles.ry):
            dist_left = self.distance(lx, ly)  
            dist_right = self.distance(rx, ry)  
            #left corner closer. ignore right
            if dist_left <= MIN_OBSTACLE_DISTANCE and dist_left < dist_right:
                critical_x.append(lx)
                critical_y.append(ly)
                directions.append(LEFT)
            #right closer. ignore left
            elif dist_right <= MIN_OBSTACLE_DISTANCE and dist_right <= dist_left:
                critical_x.append(rx)
                critical_y.append(ry)
                directions.append(RIGHT)
        
        #if only 1 obstacle in range, simplify process
        if len(critical_x) == 1:
            #if off to left side, see if we are aligned to go past edge of 
            #obstacle
            if directions[0] == LEFT:
                x_target = critical_x[0] - CIRCUMVENT_X_DIST
            #same for right
            else:
                x_target = critical_x[0] + CIRCUMVENT_X_DIST

            y_target = critical_y[0] - CIRCUMVENT_Y_DIST

        else:
            #if there are multiple obstacles we must choose where to drive between
            critical_x = np.array(critical_x)
            critical_y = np.array(critical_y)
            #assume we want to keep driving where we were facing
            #therefore we should find the obstacles most infront of robot, and see
            #if gap is wide enough to drive through. Take abs because we want to 
            #sort values on how close they are to 0. don't care about sign.
            indices = np.argsort(np.abs(critical_x))
            sorted_x = critical_x[indices]
            sorted_y = critical_y[indices]
            sorted_directions = np.array(directions, dtype=np.bool)[indices]

            #then, take difference between obstacles where we are looking at opposite corners
            #We know this indicates we could drive through the obstacles
            x_left, y_left = sorted_x[sorted_directions == LEFT],sorted_y[sorted_directions == LEFT]
            x_right, y_right = sorted_x[sorted_directions == RIGHT], sorted_y[sorted_directions == RIGHT]
            gaps = np.abs(x_right - x_left)   
            x_target, y_target = None, None
            for i,gap in enumerate(gaps):
                #as soon as we have a gap big enough, try and drive through that.
                if gap >= ROBOT_X_WIDTH:
                    #take middle of gap as target
                    x_target = (x_right[i] + x_left[i])/2
                    y_target = (y_right[i] + y_left[i])/2
                    break

            #No gaps, so must drive around furthest obstacle - just choose right direction.
            if x_target is None:
                x_target = x_right[-1] + CIRCUMVENT_X_DIST
                y_target = y_right[-1] - CIRCUMVENT_Y_DIST

        #then check alignment.
        if not aligned((x_target, y_target)):
            #must rotate 
            align_degrees = self.calculate_align((x_target, y_target))
            if align_degrees > 90.0:
                direction = self.CCW
            else:
                direction = self.CW
            speed = self.proportional_control(align_degrees, 90.0)
            return MotorCmd(direction, speed)
        #otherwise we are aligned, so just drive forward towards edge of target
        else:
            return MotorCmd(self.FORWARD, CIRCUMVENT_SPEED)

    def collect(self):
        #Call collect service
        rospy.wait_for_service('/actuator/collect')
        try:
            proxy = rospy.ServiceProxy('/actuator/collect', Trigger)
            resp = proxy()
            rospy.loginfo(resp.message)
            #Move to search state
            self.state = self.SEARCH
        except rospy.ServiceException as e:
            rospy.logerror(str(e))
            time.sleep(0.2)
        
        #if service call fails remain in collect state to try again
        return MotorCmd(self.STOP, 0.0)        

    def collision_imminent(self):
        '''
        Detect of obstacle collision is imminent
        '''
        #object base is between (lx, ly) and (rx, ry)
        for lx, ly, rx, ry in enumerate(obstacles.lx, obstacles.ly, obstacles.rx, obstacles.ry):
            #calculate distance of extremities. If any is too close, don't need to check any further
            if self.distance(lx, ly) <= MIN_OBSTACLE_DISTANCE or self.distance(rx, ry) <= MIN_OBSTACLE_DISTANCE:
                return True
        return False
    
    @staticmethod
    def distance(x, y):
        '''
        Helper static method to calculate distance to x, y coordinate
        '''
        return math.sqrt(x**2 + y**2)

    def obstacle_callback(self, obstacles):
        '''
        Update obstacles
        NB obstacles store list of x, y coordinates
        of bottom left and right corner of detected obstacles
        '''
        self.obstacles = obstacles

    def target_callback(self, targets):
        '''
        Update targets
        NB targets are list of x, y coordinates representing centre of detected
        targets
        '''
        self.targets = targets

    def proportional_control(self, target, current):
        '''
        Proportional speed control function
        that clips output in 0 to 1 range
        '''
        try:
            error = abs(target - current)/target
        except ZeroDivisionError:
            return 0.0
        #apply Kp or clip values if necessary
        return max(0.0, min(Kp*error, 1.0))
    
    def step(self):
        '''
        Given current state and available data, execute one 'step' in appropriate
        direction
        '''
        #defer to state callbacks to handle determining next step
        return self.STEP_TABLE[self.state]()

def path_planner_node():
    pub = rospy.Publisher('/actuators/motor_cmds', MotorCmd, queue_size=2)
    rospy.init_node('path_planner_node', anonymous=False)

    planner = PathPlanner() 

    obstacle_sub = rospy.Subscriber('/planner/obstacles', Obstacles, planner.obstacle_callback)
    target_sub = rospy.Subscriber('/planner/targets', Targets, planner.target_callback)

    rate = rospy.Rate(RATE)
    rospy.loginfo('Starting path planner node')
    
    while not rospy.is_shutdown():
        msg = planner.step() #take step in most appropriate direction
        pub.publish(msg)
        rate.sleep()

if __name__ == '__main__':
    try:
        path_planner_node()
    except rospy.ROSInterruptException:
        pass

